__author__ = 'andrewpboyle'
import config
import copy
import utils
from collections import namedtuple, Counter


minimax_result = namedtuple('minimax_result', ['score', 'index'])


"""
*******************************************************************************
*********************************** BOARD *************************************
*******************************************************************************
"""


def is_full_board(board):
    """
    Check if the board is full.  i.e. there are no empty spaces.

    @return: True if the board is full, False if not.
    """
    return config.NO_PLAYER not in board


def is_valid_board(board):
    """
    Check if the board is valid.  The board is considered valid if the sum of
    all values in the board, sum, is such that -1 <= sum <= 1, the only values in
    the board are config.COMPUTER, config.HUMAN, and config.NO_PLAYER, and the length
    of the board is 9.

    @param board: the board state you want to check.
    @return: True if the board is considered valid, False if not.
    """
    valid = len(board) == 9
    valid &= -1 <= sum(board) <= 1
    valid &= reduce(lambda x, y: x and y, [utils.is_valid_player(p) for p in board])
    return valid


def player_has_won(board, player):
    """
    Check if the given player has won the game on the given board.

    @param board: The board you want to evaluate.
    @param player: The player you are checking.
    @return: True if player has won the game on the given board, False
    if not.
    """
    check = 0b000000000
    for index in range(9):
        if board[index] == player:
            check |= (1 << index)
    for pattern in config.WINNING_PATTERNS:
        if pattern & check == pattern:
            return True
    return False


def get_all_moves(board, player):
    """
    Get a list of all moves available to the player in the current board.

    @param board: the board state you want to evaluate.
    @param player: the player you are getting moves for.
    @return: A list of all the moves available to the given player on the
    given board.  If the board is invalid, the player has won, or the
    player's opponent has won, then there are no moves to make so an
    empty list is returned.
    """
    moves = []
    if not (player_has_won(board, player) or
            player_has_won(board, utils.get_opponent(player)) or
            (not is_valid_board(board))):
        for index in range(9):
            if board[index] == config.NO_PLAYER:
                moves += [index]
    return moves


def get_game_state(board):
    """
    Check the state of the given board and return a message depending on the
     board state.

    @param board: The board you want to check.
    @return: a tuple with the form (board_state, message) based on the state of the
    current board.  If the board is not valid, the state will be error.  If the
    computer has one, the state will be cpu_wins.  If the player has won, the state
    will be user_wins.  If the game is still going, it will be ongoing.
    """
    if not is_valid_board(board):
        return config.ERROR, 'The given board is not valid.'
    if player_has_won(board, config.COMPUTER):
        return config.CPU_WINS, 'Computer wins.'
    elif player_has_won(board, config.HUMAN):
        return config.USER_WINS, 'User wins.'
    elif is_full_board(board):
        return config.CATS_GAME, "Cat's game"
    return config.ONGOING, 'Ongoing.'


def make_move(board, index, p):
    """
    Checks to see that the move is valid.

    @param board: the board state you want to check.
    @param index: the index of the board array where you want to make
    the move for p.
    @param p: the game_player making the move. p=1 or p=-1
    @return: Returns a board representing the new board state if index is a
    valid move.  If p is not a valid value for a game_player, it will raise an
    exception.  If the resulting board is invalid (say you have 3 X moves and 1 O
    move) it will also throw an exception.
    """
    if not utils.is_valid_player(p) or p == config.NO_PLAYER:
        raise Exception('Input p must = {0} or {1}.  p = {3}'.format(config.HUMAN, config.COMPUTER, p))
    result = copy.deepcopy(board)
    result[index] = p
    if not is_valid_board(result):
        raise Exception('Move for {0} at {1} is invalid.'.format(p, index))
    return result


"""
*******************************************************************************
************************************* AI **************************************
*******************************************************************************
"""


def get_move(board, player):
    """
    Get the best move for the given player based on the provided board.  Uses the
    minimax algorithm with alpha-beta pruning.

    @param board: a 1D array as generated by the game_board module representing the
    current tic-tac-toe board.
    @param player: the (int) value of the player looking to get the best move possible.
    @return: An int representing the index in the array representing the board that is
    the best move for the given player based on the provided board state.
    """
    #optimization to always pick the top-left corner on an empty board
    if set(board) == set([config.NO_PLAYER]):
        return 0
    result = minimax(board, player, 2, config.NEG_INF, config.INF)
    return result.index


def minimax(board, player, depth, alpha, beta):
    """
    I researched the algorithm for the tic-tac-toe ai here:
    http://www.ntu.edu.sg/home/ehchua/programming/java/JavaGame_TicTacToe_AI.html
    Additional research at :
    http://en.wikipedia.org/wiki/Minimax#Minimax_algorithm_with_alternate_moves
    http://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning

    Uses the Minimax algorithm with alpha-beta pruning.
    Returns the best move for the provided player on the given board as a
    minimax_result namedtuple.  This tuple has the score of the minimax algorithm
    as well as the x and y of the best move.

    @param board: a 1D array as generated by the game_board module representing the
    current tic-tac-toe board.
    @param player: the (int) value of the player looking to get the best move possible.
    @param depth: the depth of the tree to search.  In tic-tac-toe, we are only looking one
    move ahead so we use 2 as the value.
    @param alpha: the default alpha for alpha-beta pruning.  We use -inf.
    @param beta: the default beta for alpha-beta pruning.  We use inf.
    @return: An int representing the best move for the provided player.  The int will
    be the index on the given board where the given player should make their move.
    """
    best_index = -1
    moves = get_all_moves(board, player)
    opponent = utils.get_opponent(player)
    if moves == [] or depth == 0:
        return minimax_result(score=evaluate(board, config.COMPUTER), index=best_index)
    else:
        for move in moves:
            new_board = make_move(board, move, player)
            result = minimax(new_board, opponent, depth - 1, alpha, beta)
            if player == config.COMPUTER and result.score > alpha:
                    alpha = result.score
                    best_index = move
            elif player == config.HUMAN and result.score < beta:
                    beta = result.score
                    best_index = move
            if alpha >= beta:
                break
    best_score = alpha if player == config.COMPUTER else beta
    return minimax_result(score=best_score, index=best_index)


def evaluate(board, player):
    """
    Evaluates the given board, returning the score for the provided player.

    @param board: the tic-tac-toe board you want to evaluate.
    @param player: the player who you are trying to find the best play for.
    @return: An int representing the score for the given board.  This score is
    used to evaluate the board in the minimax algorithm.
    """
    score = 0
    for i in range(3):
        row = i * 3
        score += evaluate_line(board, player, i, i + 3, i + 6)
        score += evaluate_line(board, player, row, row + 1, row + 2)
    score += evaluate_line(board, player, 0, 4, 8)
    score += evaluate_line(board, player, 2, 4, 6)
    return score


def evaluate_line(board, player, index1, index2, index3):
    """
    Evaluates a line in board given by index1, index2, index3
    for the provided player.  Returns a score for that line assuming
    player is the max player and get_opponent(player) is the min player.
    You can see more details at the sites where I researched this
    algorithm.

    @param board: the tic-tac-toe board you want to evaluate.
    @param player: the max player you are scoring the line for.
    @param index1: first index in board that you want to check.
    @param index2: second index in board that you want to check.
    @param index3: third index in board that you want to check.
    @return: will return an int value based on the contents of the line
    given by index1, index2, and index3.  Possible values are:
        - +100: all three spaces have player values (player wins)
        - +10: two spaces have player values, the remaining one is blank
        - +1: one space has a player value, the remaining two are blank
        - 0: there is at least one player value and one opponent value
            (the line is dead)
        - -1: one space has an opponent value, the remaining two are blank
        - -10: two spaces have opponent values, the remaining one is blank
        - -100: all three spaces have opponent values (opponent wins)
    """
    opponent = utils.get_opponent(player)
    line_counts = Counter([board[index1], board[index2], board[index3]])
    if line_counts[player] > 0 and line_counts[opponent] > 0:
        return 0  # line has player and opponent values = dead line
    if line_counts[opponent] == 0:
        return int(pow(10, line_counts[player] - 1))  # line has only player values
    return -int(pow(10, line_counts[opponent] - 1)) # line has only opponent values