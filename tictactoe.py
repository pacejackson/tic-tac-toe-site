__author__ = 'andrewpboyle'
import config
import copy
import utils
import logging
from collections import namedtuple


minimax_result = namedtuple('minimax_result', ['score', 'index'])


"""
*******************************************************************************
*********************************** BOARD *************************************
*******************************************************************************
"""


def is_full_board(board):
    """
    Returns True if the board is full.  i.e. there are no empty spaces.
    """
    return config.NO_PLAYER not in board


def is_valid_board(board):
    """
    Returns True if the board is valid.  The board is considered valid if the sum of
    all values in the board, sum, is such that -1 <= sum <= 1, the only values in
    the board are config.COMPUTER, config.HUMAN, and config.NO_PLAYER, and the length
    of the board is 9.

    board - the board state you want to check.
    """
    valid = len(board) == 9
    valid &= -1 <= sum(board) <= 1
    valid &= reduce(lambda x, y: x and y, [utils.is_valid_player(p) for p in board])
    return valid


def player_has_won(board, player):
    """
    Returns True if player has won, False if not.

    board - the board state you want to evaluate.
    player - the player you are checking
    """
    check = 0b000000000
    for index in range(9):
        if board[index] == player:
            check |= (1 << index)
    for pattern in config.WINNING_PATTERNS:
        if pattern & check == pattern:
            return True
    return False


def get_all_moves(board, player):
    """
    Returns a list of all moves available to the player in the current board.

    board - the board state you want to evaluate.
    player - the player you are getting moves for.
    """
    moves = []
    if not (player_has_won(board, player) or
            player_has_won(board, utils.get_opponent(player)) or
            (not is_valid_board(board))):
        for index in range(9):
            if board[index] == config.NO_PLAYER:
                moves += [index]
    return moves


def get_game_state(board):
    """
    Returns a tuple with the form (board_state, message) based on the state of the
    current board.  If the board is not valid, the state will be error.  If the
    computer has one, the state will be cpu_wins.  If the player has won, the state
    will be user_wins.  If the game is still going, it will be ongoing.
    """
    if not is_valid_board(board):
        return config.ERROR, 'The given board is not valid.'
    if player_has_won(board, config.COMPUTER):
        return config.CPU_WINS, 'Computer wins.'
    elif player_has_won(board, config.HUMAN):
        return config.USER_WINS, 'User wins.'
    elif is_full_board(board):
        return config.CATS_GAME, "Cat's game"
    return config.ONGOING, 'Ongoing.'


def make_move(board, index, p):
    """
    Checks to see that the move is valid.  If it is, it returns a board representing
    the new board state.  If p is not a valid value for a game_player, it will raise an
    exception.  If the resulting board is invalid (say you have 3 X moves and 1 O
    move) it will also throw an exception.  See _check_point for any other exceptions
    the function may throw.

    board - the board state you want to check.
    x - the column where your point is in 2D.  0 <= x <= 2
    y - the row where your point is in 2D.  0 <= y <= 2
    p - the game_player making the move. p=1 or p=-1
    """
    if not utils.is_valid_player(p) or p == config.NO_PLAYER:
        raise Exception('Input p must = {0} or {1}.  p = {3}'.format(config.HUMAN, config.COMPUTER, p))
    result = copy.deepcopy(board)
    result[index] = p
    if not is_valid_board(result):
        raise Exception('Move for {0} at {1} is invalid.'.format(p, index))
    return result


"""
*******************************************************************************
************************************* AI **************************************
*******************************************************************************
"""


def get_move(board, player):
    """
    Get the best move (x, y) for the given player based on the provided board.

    board - a 1D array as generated by the game_board module representing the
    current tic-tac-toe board.
    player - the (int) value of the player looking to get the best move possible.
    """
    #optimization to always pick the top-left corner on an empty board
    if set(board) == set([config.NO_PLAYER]):
        return 0
    result = minimax(board, player, 2, config.NEG_INF, config.INF)
    return result.index


def minimax(board, player, depth, alpha, beta):
    """
    I researched the algorithm for the tic-tac-toe ai here:
    http://www.ntu.edu.sg/home/ehchua/programming/java/JavaGame_TicTacToe_AI.html
    Additional research at :
    http://en.wikipedia.org/wiki/Minimax#Minimax_algorithm_with_alternate_moves
    http://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning

    Uses the Minimax algorithm with alpha-beta pruning.
    Returns the best move for the provided player on the given board as a
    minimax_result namedtuple.  This tuple has the score of the minimax algorithm
    as well as the x and y of the best move.

    board - a 1D array as generated by the game_board module representing the
    current tic-tac-toe board.
    player - the (int) value of the player looking to get the best move possible.
    depth - the depth of the tree to search.  In tic-tac-toe, we are only looking one
    move ahead so we use 2 as the value.
    alpha - the default alpha for alpha-beta pruning.  We use -inf.
    beta - the default beta for alpha-beta pruning.  We use inf.
    """
    best_index = -1
    moves = get_all_moves(board, player)
    opponent = utils.get_opponent(player)
    if moves == [] or depth == 0:
        return minimax_result(score=evaluate(board, config.COMPUTER), index=best_index)
    else:
        for move in moves:
            new_board = make_move(board, move, player)
            result = minimax(new_board, opponent, depth - 1, alpha, beta)
            if player == config.COMPUTER and result.score > alpha:
                    alpha = result.score
                    best_index = move
            elif player == config.HUMAN and result.score < beta:
                    beta = result.score
                    best_index = move
            if alpha >= beta:
                break
    best_score = alpha if player == config.COMPUTER else beta
    return minimax_result(score=best_score, index=best_index)


def evaluate(board, player):
    """
    Evaluates the given board, returning the score for the provided player.

    board - the tic-tac-toe board you want to evaluate.
    player - the player who you are trying to find the best play for.
    """
    score = 0
    for i in range(3):
        col = i
        row = i * 3
        #evaluate rows
        score += evaluate_line(board, player, col, col + 3, col + 6)
        #evaluate columns
        score += evaluate_line(board, player, row, row + 1, row + 2)
    #evaluate diagonals
    score += evaluate_line(board, player, 0, 4, 8)
    score += evaluate_line(board, player, 2, 4, 6)
    return score


def evaluate_line(board, player, index1, index2, index3):
    """
    Evaluates a line in board given by x1, y1, x2, y2, x3, y3
    for the provided player.  Returns a score for that line assuming
    player is the max player and get_opponent(player) is the min player.
    You can see more details at the sites where I researched this
    algorithm.

    ___TODO___: see if you can find a better heuristic for this.

    board - the tic-tac-toe board you want to evaluate.
    player - the max player you are scoring the line for
    x1, y1, x2, y2, x3, y3 - 2D points defining the line you want to
    check.
    """
    score = 0
    opponent = utils.get_opponent(player)

    state_1 = board[index1]
    if state_1 == player:
        score = 1
    elif state_1 == opponent:
        score = -1

    state_2 = board[index2]
    if state_2 == player:
        if score == 1:
            score = 10
        elif score == -1:
            return 0
        else:
            score = 1
    elif state_2 == opponent:
        if score == -1:
            score = -10
        elif score == 1:
            return 0
        else:
            score = -1

    state_3 = board[index3]
    if state_3 == player:
        if score > 0:
            score *= 10
        elif score < 0:
            return 0
        else:
            score = 1
    elif state_3 == opponent:
        if score < 0:
            score *= 10
        elif score > 1:
            return 0
        else:
            score = -1

    return score
