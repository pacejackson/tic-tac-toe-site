__author__ = 'andrewpboyle'
from game_board import get_all_moves, make_move, get_state_at_point
from game_player import get_opponent
from collections import namedtuple
import config

INF = float('inf')
NEG_INF = float('-inf')


minimax_result = namedtuple('minimax_result', ['score', 'x', 'y'])


def get_move(board, player):
    """
    Get the best move (x, y) for the given player based on the provided board.

    board - a 1D array as generated by the game_board module representing the
    current tic-tac-toe board.
    player - the (int) value of the player looking to get the best move possible.
    """
    result = _minimax(board, 2, player, NEG_INF, INF)
    return result.x, result.y


def _minimax(board, depth, player, alpha, beta):
    """
    I researched the algorithm for the tic-tac-toe ai here:
    http://www.ntu.edu.sg/home/ehchua/programming/java/JavaGame_TicTacToe_AI.html
    Additional research at :
    http://en.wikipedia.org/wiki/Minimax#Minimax_algorithm_with_alternate_moves
    http://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning
    """
    best_x = -1
    best_y = -1
    moves = get_all_moves(board, player)
    if moves == [] or depth == 0:
        score = _evaluate(board, player)
        return minimax_result(score=score, x=best_x, y=best_y)
    else:
        for move in moves:
            if player == config.computer:
                result = _minimax(make_move(board, move[0], move[1]), depth - 1, get_opponent(player), alpha, beta)
                if result.score > alpha:
                    best_x = result.x
                    best_y = result.y
                    alpha = result.score
            else:
                result = _minimax(make_move(board, move[0], move[1]), depth - 1, get_opponent(player), alpha, beta)
                if result.score < beta:
                    beta = result.score
                    best_x = result.x
                    best_y = result.y
            if alpha >= beta:
                break
    best_score = alpha if player == config.computer else beta
    return minimax_result(score=best_score, x=best_x, y=best_y)


def _evaluate(board, player):
    """
    Evaluates the given board, returning the score for the provided player.
    """
    score = 0
    #evaluate cols
    score += _evaluate_line(board, player, 0, 0, 0, 1, 0, 2)
    score += _evaluate_line(board, player, 1, 0, 1, 1, 1, 2)
    score += _evaluate_line(board, player, 2, 0, 2, 1, 2, 2)
    #evaluate rows
    score += _evaluate_line(board, player, 0, 0, 1, 0, 2, 0)
    score += _evaluate_line(board, player, 0, 1, 1, 1, 2, 1)
    score += _evaluate_line(board, player, 0, 2, 1, 2, 2, 2)
    #evaluate diags
    score += _evaluate_line(board, player, 0, 0, 1, 1, 2, 2)
    score += _evaluate_line(board, player, 2, 0, 1, 1, 0, 2)
    return score


def _evaluate_line(board, player, x1, y1, x2, y2, x3, y3):
    score = 0
    opponent = get_opponent(player)

    state_1 = get_state_at_point(board, x1, y1)
    if state_1 == player:
        score = 1
    elif state_1 == opponent:
        score = -1

    state_2 = get_state_at_point(board, x2, y2)
    if state_2 == player:
        if score == 1:
            score = 10
        elif score == -1:
            return 0
        else:
            score = -1
    elif state_2 == opponent:
        if score == 1:
            return 0
        elif score == -1:
            score = -10
        else:
            score = -1

    state_3 = get_state_at_point(board, x3, y3)
    if state_3 == player:
        if score > 0:
            score *= 10
        elif score < 0:
            return 0
        else:
            score = 1
    elif state_3 == opponent:
        if score < 0:
            score *= 10
        elif score > 0:
            return 0
        else:
            score = -1

    return score
