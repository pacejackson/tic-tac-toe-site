__author__ = 'andrewpboyle'
from game_board import get_all_moves, make_move
from game_player import get_opponent
from collections import namedtuple
import config

INF = float('inf')
NEG_INF = float('-inf')


minimax_result = namedtuple('minimax_result', ['score', 'x', 'y'])


def get_move(board, player):
    """
    Get the best move (x, y) for the given player based on the provided board.

    board - a 1D array as generated by the game_board module representing the
    current tic-tac-toe board.
    player - the (int) value of the player looking to get the best move possible.
    """
    result = _minimax(board, 2, player, INF, NEG_INF)
    return result.x, result.y


def _minimax(board, depth, player, alpha, beta):
    """
    I researched the algorithm for the tic-tac-toe ai here:
    http://www.ntu.edu.sg/home/ehchua/programming/java/JavaGame_TicTacToe_AI.html
    Additional research at :
    http://en.wikipedia.org/wiki/Minimax#Minimax_algorithm_with_alternate_moves
    http://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning
    """
    best_x = -1
    best_y = -1
    moves = get_all_moves(board, player)
    if moves == [] or depth == 0:
        score = _evaluate(board, player)
        return minimax_result(score=score, x=best_x, y=best_y)
    else:
        for move in moves:
            if player == config.computer:
                result = _minimax(make_move(board, move[0], move[1]), depth - 1, get_opponent(player), alpha, beta)
                if result.score > alpha:
                    best_x = result.x
                    best_y = result.y
                    alpha = result.score
            else:
                result = _minimax(make_move(board, move[0], move[1]), depth - 1, get_opponent(player), alpha, beta)
                if result.score < beta:
                    beta = result.score
                    best_x = result.x
                    best_y = result.y
            if alpha >= beta:
                break
    best_score = alpha if player == config.computer else beta
    return minimax_result(score=best_score, x=best_x, y=best_y)


def _evaluate(board, player):
    pass