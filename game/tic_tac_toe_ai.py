__author__ = 'andrewpboyle'
from game_board import get_all_moves, make_move, get_state_at_point, is_empty
from game_player import get_opponent
from collections import namedtuple
import config

INF = float('inf')
NEG_INF = float('-inf')


minimax_result = namedtuple('minimax_result', ['score', 'x', 'y'])


def get_move(board, player):
    """
    Get the best move (x, y) for the given player based on the provided board.

    board - a 1D array as generated by the game_board module representing the
    current tic-tac-toe board.
    player - the (int) value of the player looking to get the best move possible.
    """
    #optimization to always pick the top-left corner on an empty board
    if is_empty(board):
        return 0, 0
    result = minimax(board, player, 2, NEG_INF, INF)
    return result.x, result.y


def minimax(board, player, depth, alpha, beta):
    """
    I researched the algorithm for the tic-tac-toe ai here:
    http://www.ntu.edu.sg/home/ehchua/programming/java/JavaGame_TicTacToe_AI.html
    Additional research at :
    http://en.wikipedia.org/wiki/Minimax#Minimax_algorithm_with_alternate_moves
    http://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning

    Uses the Minimax algorithm with alpha-beta pruning.
    Returns the best move for the provided player on the given board as a
    minimax_result namedtuple.  This tuple has the score of the minimax algorithm
    as well as the x and y of the best move.

    board - a 1D array as generated by the game_board module representing the
    current tic-tac-toe board.
    player - the (int) value of the player looking to get the best move possible.
    depth - the depth of the tree to search.  In tic-tac-toe, we are only looking one
    move ahead so we use 2 as the value.
    alpha - the default alpha for alpha-beta pruning.  We use -inf.
    beta - the default beta for alpha-beta pruning.  We use inf.
    """
    best_x = -1
    best_y = -1
    moves = get_all_moves(board, player)
    opponent = get_opponent(player)
    if moves == [] or depth == 0:
        score = evaluate(board, config.computer)
        return minimax_result(score=score, x=best_x, y=best_y)
    else:
        for move in moves:
            new_board = make_move(board, move[0], move[1], player)
            if player == config.computer:
                result = minimax(new_board, opponent, depth - 1, alpha, beta)
                if result.score > alpha:
                    alpha = result.score
                    best_x = move[0]
                    best_y = move[1]
            else:
                result = minimax(new_board, opponent, depth - 1, alpha, beta)
                if result.score < beta:
                    beta = result.score
                    best_x = move[0]
                    best_y = move[1]
            if alpha >= beta:
                break
    best_score = alpha if player == config.computer else beta
    return minimax_result(score=best_score, x=best_x, y=best_y)


def evaluate(board, player):
    """
    Evaluates the given board, returning the score for the provided player.

    board - the tic-tac-toe board you want to evaluate.
    player - the player who you are trying to find the best play for.
    """
    score = 0
    #evaluate cols
    score += evaluate_line(board, player, 0, 0, 0, 1, 0, 2)
    score += evaluate_line(board, player, 1, 0, 1, 1, 1, 2)
    score += evaluate_line(board, player, 2, 0, 2, 1, 2, 2)
    #evaluate rows
    score += evaluate_line(board, player, 0, 0, 1, 0, 2, 0)
    score += evaluate_line(board, player, 0, 1, 1, 1, 2, 1)
    score += evaluate_line(board, player, 0, 2, 1, 2, 2, 2)
    #evaluate diags
    score += evaluate_line(board, player, 0, 0, 1, 1, 2, 2)
    score += evaluate_line(board, player, 2, 0, 1, 1, 0, 2)
    return score


def evaluate_line(board, player, x1, y1, x2, y2, x3, y3):
    """
    Evaluates a line in board given by x1, y1, x2, y2, x3, y3
    for the provided player.  Returns a score for that line assuming
    player is the max player and get_opponent(player) is the min player.
    You can see more details at the sites where I researched this
    algorithm.

    board - the tic-tac-toe board you want to evaluate.
    player - the max player you are scoring the line for
    x1, y1, x2, y2, x3, y3 - 2D points defining the line you want to
    check.
    """
    score = 0
    opponent = get_opponent(player)

    state_1 = get_state_at_point(board, x1, y1)
    if state_1 == player:
        score = 1
    elif state_1 == opponent:
        score = -1

    state_2 = get_state_at_point(board, x2, y2)
    if state_2 == player:
        if score == 1:
            score = 10
        elif score == -1:
            return 0
        else:
            score = 1
    elif state_2 == opponent:
        if score == -1:
            score = -10
        elif score == 1:
            return 0
        else:
            score = -1

    state_3 = get_state_at_point(board, x3, y3)
    if state_3 == player:
        if score > 0:
            score *= 10
        elif score < 0:
            return 0
        else:
            score = 1
    elif state_3 == opponent:
        if score < 0:
            score *= 10
        elif score > 1:
            return 0
        else:
            score = -1

    return score
